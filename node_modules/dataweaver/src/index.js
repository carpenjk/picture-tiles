const _getVal = (v, props, br) => {
  let values = typeof v == 'function' ? v(props, br) : v;
  if (Array.isArray(values)) return values[br];
  return values;
};

export const parseSizeUnits = (valUnits) => {
  function parseSizeUnit(valUnit) {
    const exp = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/;
    let matches = [];
    matches = valUnit.match(exp);
    if (matches) {
      return { whole: matches[0], value: matches[1], unit: matches[2] };
    }
    return { whole: valUnit };
  }
  if (!Array.isArray(valUnits)) {
    return parseSizeUnit(valUnits);
  }
  return valUnits.map((val) => parseSizeUnit(val));
}

export const getProp = (prop) => (props, br) => {
  //props automatically passed as first prop in breakpoint function
  const propValues = props[prop];
  if (!Array.isArray(propValues)) {
    return propValues;
  }
  let value = '';
  if (!br) {
    value = propValues[0];
  } else if (br < propValues.length) {
    value = propValues[br];
  } else {
    value = propValues[propValues.length - 1];
  }

  return value;
};


export const getConditionalProp = (prop, fn) => (props, br) => {
  const propValue = getProp(prop)(props, br);

  return fn({ props: props, [prop]: propValue });
};

export const inverseProps = (prop) => {
  if (!Array.isArray(prop)) {
    return !prop;
  } else {
    return prop.map((item) => !item);
  }
};


// unflattenProps:
// transforms array of props into an object of prop arrays
// ex.
// from:
// [
//   {
//    top: '100px',
//    left: '50%',
//    transform: 'translateX(-50%)',
//  },
//  {
//    top: '50%',
//    transform: 'translateY(-50%)'
//  }
// ]
// to:
// {
//   top: ['100px', '50%'],
//   left: ['50%', ''],
//   transform:  ['translateX(-50%)', 'translateY(-50%)']
// }
//
// if defaults provided, then empty slots in the array will be infused with default value.
// this is helplful because getProps gets the nearest smaller breakpoint value. Using a default
// reinfuses the default value instead.
//@params defaults ex. 1 {left: ['8px', '0']}  || ex. 2 {left: '8px'}

export const unflattenProps = (props, defaultValues, options) => {
  const {noValue =  ''} = options || {};
  if(!Array.isArray(props)){
    return props;
  }
  function createSuperSet(propAry) {
    const superSetObj = {};
    // iterate through each key pair property object
    propAry.forEach((obj) => {
      // iterate through key pairs of current prop object
      Object.keys(obj).forEach((p) => {
        // add key to superSetObject
        superSetObj[p] = [];
      });
    });
    return superSetObj;
  }

  const unFlattened = createSuperSet(props);

  const resultLength = props.length;
  for (let i = 0; i < resultLength; i += 1) {
    Object.keys(unFlattened).forEach((key) => {
      // if key exists in current propArry obj, push value, else push default
      const curValue = props[i][key];
      if (curValue !== undefined) {
        unFlattened[key].push(curValue);
      } else {
        const defaultValue = defaultValues[key] !== undefined ? getProp(key)(defaultValues, i) : undefined;
        if(defaultValue !== undefined){
          unFlattened[key].push(defaultValue);
        }
      }
    });
  }
  return unFlattened;
}


// flattenProps:
// transforms an object of prop arrays into an array of props
// this is useful in combination with mapFlatProp to apply logic to each set of 
// values corresponding to a breakpoint
// the last value in each prop array will be carried forward to mirror getProps by default
// @param defaultValues: [{ prop: a || [a, b, c...] }, ...] 
// default values will be used to fill in gaps for any provided values overwriting carryforward value
// Options:
// @option useNoValue: true || false (default)
// useNoValue overwrites carryforward in the event of no default value
//@option noValue: any value || undefined (default)
export const flattenProps = (props, defaultValues, options) => {
  const {noValue, useNoValue = false} = options || {};
  //first iteration return value
  function getCurrValue(k, i){
    //return static values on first iteration
    const values= props[k];
    if(!Array.isArray(values)){
      if(i !== 0){
        return;
      } else{
        return {[k]:values[i]};
      }
    }
    const pAryLength = values.length;
    if(i >= pAryLength){
      //no value at this iteration
      return;
    }
    // return curr value
    return {[k]: values[i]};
  }

  let flattenedProps = [];
  const keys = Object.keys(props)
  const resultLength  = Math.max(...keys.map((k) => {
    const values = props[k];
    return Array.isArray(values) ? values.length : 1;
  }));

  for(let i = 0; i < resultLength; i+=1){
    const propObj  = keys.reduce((obj, p) => {
      //use current value if exist in prop set
      const currVal = getCurrValue(p, i);
      if( currVal !== undefined){
        return {...obj, ...getCurrValue(p, i)};
      } else if(defaultValues[p] !== undefined) {
        //
        return {...obj, ...getProp(p)(defaultValues, i)};
      } else if(useNoValue) {
        return {...obj, [p]: noValue};
      } else {
        //get carry forward value
        return {...obj, [p]: getProp(p)(props, i)};
      }
      
     },{});
    flattenedProps.push(propObj);
  }
  return flattenedProps;
}

// applies a function to each set of prop values in a flattened prop array
export const mapFlatProp = (fn, propAry) => {
  if (!Array.isArray(propAry)) {
    return fn(propAry);
  }
  return propAry.map((p) => fn(p));
}

//@param cnd(option1): callback function returns boolean and accepts params props, br (optional)
//@param cnd(option2): string value of property name
export const condition = (cnd) => (...args) => (props, br) => {
  let cndBln = '';

  if (typeof cnd == 'function') {
    //call function
    cndBln = cnd(props, br);
  } else if (typeof cnd == 'string') {
    cndBln = getProp(cnd)(props, br) ? true : false;
  } else {
    cndBln = cnd;
  }
  if (!cndBln) return '';

  let cndStyles = '';

  args[0].forEach((str, i) => {
    if (i < args.length - 1) {
      cndStyles = `${cndStyles}${str}${_getVal(args[i + 1], props, br)}`; // get variable value or call function
    } else {
      cndStyles = cndStyles + str;
    }
  });
  return cndStyles;
};


export const getNonStaticPosProps = (posObj) => {
  if (!posObj) {
    // use default positioning
    return undefined;
  }

  const { vertical, horizontal, ...pos } = posObj || {};
  function getCenterProps() {
    if (vertical && horizontal) {
      return { left: '50%', top: '50%', transform: 'translate(-50%, -50%)' };
    }
    if (vertical) {
      return { top: '50%', transform: 'translateY(-50%)' };
    }
    if (horizontal) {
      return { left: '50%', transform: 'translateX(-50%)' };
    }
  }
  if (vertical && horizontal) {
    // positions don't apply
    return getCenterProps();
  }
  const positions = Object.keys(pos).reduce(
    (obj, k) => (typeof pos[k] !== 'function' ? { ...obj, [k]: pos[k] } : obj),
    {}
  );
  return { ...positions, ...getCenterProps() };
}

export const getComponentData = (semKey, data) => {
  const compData = data[semKey];
  //set optional properties to '' for destructuring;
  compData.Layout = compData.Layout ? compData.Layout : '';
  return { [semKey]: compData };
};

export const getSubComponentData = (semKey, data, i) => {
  const compData = getComponentData(semKey, data);
  if (!compData[semKey].items) return undefined;
  const subCompData = compData[semKey].items[i];
  return { [semKey]: subCompData };
};

export const getSubComponentProps = (semKey, data) => {
  return { semKey: semKey, data: getComponentData(semKey, data) };
};

const dw_prop = (prop, theme) => getProp(prop)
export const dw = {
  prop: getProp()
}
