const _DEFAULT_VARIANT = 'default';
const sysUILookup = {
  color: ['colors', 'color'],
  backgroundColor: ['colors', 'bg'],
  borderColor: ['colors', 'borderColor'],
  lineHeight: 'lineHeights',
  letterSpacing: 'letterSpacings',
  fontFamily: 'fonts',
  fontSize: 'fontSizes',
  fontWeight: 'fontWeights',
  margin: ['space', 'margin'],
  marginTop: ['space', 'marginTop'],
  marginRight: ['space', 'marginRight'],
  marginBottom: ['space', 'marginBottom'],
  marginLeft: ['space', 'marginLeft'],
  padding: ['space', 'padding'],
  paddingTop: ['space', 'paddingTop'],
  paddingRight: ['space', 'paddingRight'],
  paddingBottom: ['space', 'paddingBottom'],
  paddingLeft: ['space', 'paddingLeft'],
  width: ['sizes', 'width'],
  height: ['sizes', 'height'],
  minWidth: ['sizes', 'minWidth'],
  minHeight: ['sizes', 'minHeight'],
  maxWidth: ['sizes', 'maxWidth'],
  maxHeight: ['sizes', 'maxHeight'],
  border: ['borders', 'border'],
  borderTop: ['borders', 'borderTop'],
  borderRight: ['borders', 'borderRight'],
  borderBottom: ['borders', 'borderBottom'],
  borderLeft: ['borders', 'borderLeft'],
  borderWidth: 'borderWidths',
  borderStyle: 'borderStyles',
  borderRadius: 'radii',
  boxShadow: 'shadows',
  textShadow: 'shadows',
  zIndex: 'zIndices',
  transition: 'transitions',
};

function _createEmptyLevel(ref, p) {
  if (!ref[p]) ref[p] = {}; // create system key or style/qualifiers
  return ref[p]; //set rolling reference point in object
}

const _drill = (ref, keys) => {
  let refCopy = Array.isArray(ref) ? [...ref] : { ...ref };
  keys.forEach((key) => (refCopy = refCopy[key]));
  return refCopy;
};

function _createAliasValues(values, theme, themeKey, ref, node) {
  if (Array.isArray(values)) {
    ref[node] = _lookupThemeAry(values, theme, themeKey);
  } else if (typeof values === 'object') {
    ref[node] = _createEmptyLevel(ref, node);
    Object.keys(values).forEach((key) => {
      // debugger;
      if (Array.isArray(values[key])) {
        ref[node][key] = _lookupThemeAry(values[key], theme, themeKey);
        // values[key].forEach((trans) => {
        //   ref[node][trans] = theme[themeKey][trans];
        // });
      } else {
        ref[node][key] = theme[themeKey][key];
      }
    });
  } else {
    ref[node] = theme[themeKey][values];
  }
}

const _getTheme = (path, style, theme) => {
  const pSplit = path.split('.');
  const themeUI = sysUILookup[style].split
    ? [sysUILookup[style]]
    : [...sysUILookup[style]];
  const [themeKey, ...qualifiers] = themeUI;
  const group = pSplit[0];
  const variant = pSplit.length > 1 ? pSplit[1] : _DEFAULT_VARIANT;

  const varNode = theme[themeKey][group]
    ? theme[themeKey][group][variant]
    : undefined;
  const leafNode =
    typeof varNode === 'object' ? _drill(varNode, qualifiers) : undefined;
  return leafNode || varNode;
};
function _getUnitValue(derivedValue) {
  return isNaN(derivedValue) ? derivedValue : `${derivedValue}px`;
}
const _getVal = (v, props, br) => {
  let values = typeof v == 'function' ? v(props, br) : v;
  if (Array.isArray(values)) return values[br];
  return values;
};
function _lookupThemeAry(values, theme, themeKey) {
  return values.reduce(
    (result, styleKey) => [...result, theme[themeKey][styleKey]],
    []
  );
}

function _createClassStyle(className, styles, props, br) {
  const keys = Object.keys(styles);
  let stylesCSS = '';
  keys.forEach((style) => {
    stylesCSS =
      stylesCSS +
      `${style}: ${_getVal(styles[style], props, br)};
        `;
  });
  const css = `&.${className} {
    ${stylesCSS}}`;
  return css;
}

const _getBreakpointValue = (breakpoints, br, values) => {
  if (Array.isArray(values)) {
    return _getDefinedBreakpointValue(breakpoints, br, values);
  } else {
    return values;
  }
};

const _getDefinedBreakpointValue = (breakpoints, br, values) => {
  if (br) {
    return values[br];
  } else {
    return _getUndefinedBreakpoint(breakpoints, values);
  }
};

const _getUndefinedBreakpoint = (breakpoints, values) => {
  return values[0]; //! add logic at a later date
};

export const variant = (name, styles) => {
  return {
    [name]: {
      variant: true,
      styles: { ...styles },
    },
  };
};

export function toggleClass(isOn, className) {
  if (isOn) return className;
}

export const toggleClassCSS = (className, isOn, styles) => (props) => {
  if (isOn) return _createClassStyle(className, styles, props);
};

//FUNCTION: withThemeWeaver
// Creates and returns a theme object of a specific shape for consuming
// Clones specified theme object and appends with alias strucure which
// manages styles and variantes
// @param: theme = a theme object following system-ui spec
// @param: config = style object with following shape
/* {
  nav: variant('main', {
    color: 'action',  //action is a color specified in system-ui theme object
    backgroundColor: 'secondary',
    fontFamily: 'poppins',
    fontSize: 3,
    fontWeight: 'bold',
    padding: 4,
  })     */
// nesting variant objects is optional if only one variant present and object
//can be appended with as many groups (i.e. nav) and variants as needed
export const withThemeWeaver = (theme, config) => {
  let configWithVariant = { ...config };
  let ref = theme; //moving reference for adding alias nodes starts at the top node
  let usesVariants = false;
  let groupKeys = {};

  Object.keys(config).forEach((group) => {
    groupKeys = Object.keys(config[group]);
    usesVariants = config[group][groupKeys[0]].variant;
    if (!usesVariants) {
      //! ****************************
      //if no variants are being used reshape config object with variant placeholder
      configWithVariant[group] = variant(
        _DEFAULT_VARIANT,
        configWithVariant[group]
      );
    }
    Object.keys(configWithVariant[group]).forEach((variant) => {
      Object.keys(configWithVariant[group][variant].styles).forEach((style) => {
        let themeKeys = sysUILookup[style];
        let values = configWithVariant[group][variant].styles[style];
        themeKeys = typeof themeKeys === 'object' ? themeKeys : [themeKeys];
        //1st: system key i.e colors, 2nd: category i.e. nav, 3-nth: style i.e. color, last: value
        themeKeys.forEach((key, i, keys) => {
          let isLast = i === keys.length - 1;
          if (i === 0 || !isLast) ref = _createEmptyLevel(ref, key);
          if (i === 0) {
            //create group and variant after setting system ui key
            ref = _createEmptyLevel(ref, group);
            if (!isLast) {
              ref = _createEmptyLevel(ref, variant);
            } else {
              _createAliasValues(values, theme, themeKeys[0], ref, variant);
            }
          } else if (isLast) {
            _createAliasValues(values, theme, themeKeys[0], ref, key);
          }
        });
        ref = theme; //return to top
      });
    });
  });
  return theme;
};

export const breakpoint = (br) => (...args) => (props) => {
  let media = `@media(min-Width: ${props.theme.breakpoints[br]}){`; //! dynamically retrieve
  args[0].forEach((str, i) => {
    if (i < args.length - 1) {
      media = `${media} ${str}${_getVal(args[i + 1], props, br)}`; // get variable value or call function
    } else {
      media = media + str;
    }
  });
  media = media + '}';
  return media;
};

export const getTransitions = (transitions) => (props, br) => {
  let css = '';
  const transAry = Array.isArray(transitions) ? transitions : [transitions];
  transAry.forEach((trans, i) => {
    let transitions = _getTheme(trans.path, 'transition', props.theme);
    let derivedValue = _getBreakpointValue(
      props.theme.breakpoints,
      br,
      transitions[trans.style]
    );
    css = css + derivedValue;
    if (i < transAry.length - 1) css = css + ', ';
  });
  return css;
};

export const toggleTransitions = (isTrans, trans, className) => (props, br) => {
  const transAry = Array.isArray(trans) ? trans : [trans];
  let styles = {};
  let transValues = [];
  transAry.forEach((trans) => {
    styles = { ...styles, [trans.style]: _getVal(trans.value, props, br) };
    transValues = [
      ...transValues,
      { style: trans.style, path: trans.transition, fallback: trans.fallback },
    ];
  }, {});
  return toggleClassCSS(className || 'tw-transitions', isTrans, {
    ...styles,
    transition: getTransitions(transValues)(props, br),
  })(props, br);
};

export const twTransition = (isTrans) => {
  return isTrans ? 'tw-transition' : '';
};

export const getColor = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'color', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getBackgroundColor = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'backgroundColor', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getBorderColor = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderColor', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getLineHeight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'lineHeight', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getLetterSpacing = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'letterSpacing', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getFontFamily = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'fontFamily', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getFontSize = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'fontSize', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getFontWeight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'fontWeight', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getMargin = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'margin', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMarginTop = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'marginTop', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMarginRight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'marginRight', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMarginBottom = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'marginBottom', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMarginLeft = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'marginLeft', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getPadding = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'padding', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getPaddingTop = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'paddingTop', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getPaddingRight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'paddingRight', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getPaddingBottom = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'paddingBottom', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getPaddingLeft = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'paddingLeft', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getWidth = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'width', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getHeight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'height', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMinWidth = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'minWidth', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMinHeight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'minHeight', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMaxWidth = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'maxWidth', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getMaxHeight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'maxHeight', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorder = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'border', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderTop = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderTop', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderRight = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderRight', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderBottom = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderBottom', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderLeft = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderLeft', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderWidth = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderWidth', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderRadius = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderRadius', props.theme);
  if (!themeValues) return fallbackValue;
  const derivedValue = _getBreakpointValue(
    props.theme.breakpoints,
    br,
    themeValues
  );
  return _getUnitValue(derivedValue);
};

export const getBorderStyle = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'borderStyle', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getBoxShadow = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'boxShadow', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getTextShadow = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'textShadow', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const getZIndex = (path, fallbackValue) => (props, br) => {
  let themeValues = _getTheme(path, 'zIndex', props.theme);
  if (!themeValues) return fallbackValue;
  return _getBreakpointValue(props.theme.breakpoints, br, themeValues);
};

export const tw = {
  color: getColor,
  backgroundColor: getBackgroundColor,

  lineHeight: getLineHeight,
  letterSpacing: getLetterSpacing,
  fontFamily: getFontFamily,
  fontSize: getFontSize,
  fontWeight: getFontWeight,
  margin: getMargin,
  marginTop: getMarginTop,
  marginRight: getMarginRight,
  marginBottom: getMarginBottom,
  marginLeft: getMarginLeft,
  padding: getPadding,
  paddingTop: getPadding,
  paddingRight: getPaddingRight,
  paddingBottom: getPaddingBottom,
  paddingLeft: getPaddingLeft,
  width: getWidth,
  height: getHeight,
  minWidth: getMinWidth,
  minHeight: getMinHeight,
  maxWidth: getMaxWidth,
  maxHeight: getMaxHeight,
  border: getBorder,
  borderTop: getBorderTop,
  borderRight: getBorderRight,
  borderBottom: getBorderBottom,
  borderLeft: getBorderLeft,
  borderColor: getBorderColor,
  borderWidth: getBorderWidth,
  borderStyle: getBorderStyle,
  borderRadius: getBorderRadius,
  boxShadow: getBoxShadow,
  textShadow: getTextShadow,
  zIndex: getZIndex,
  transitions: getTransitions,
  breakpoint,
  toggleTransitions,
  toggleClass,
};
